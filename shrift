#!/bin/bash

#ANSI COLORS
RED='\033[0;31m'
GREEN='\033[0;32m'
END='\033[0m'

function _usage() {
  echo "usage: $0 [args] specfile"
  echo
  echo "-h                 Help"
  echo "-d [docker|local]  Execution driver (default: local)"
  echo "-t [target]        Target for execution (host/container)"
  echo "-v                 Enable verbose output"
  echo
}

function _error() {
  echo -e "${RED}ERROR${END}: ${1}"
  exit 1
}

function _print_cmd_summary() {
  local rc=$1
  local cmd=$2
  if [[ $rc == 0 ]]; then
    echo -e "${GREEN}Success 0${END}: ${cmd}"
  else
    echo -e "${RED}Failure ${rc}${END}: ${cmd}"
  fi
}

function _print_cmd_output() {
  while read line; do
    echo "  ${line}"
  done < $1
}

function _print_dot() {
  if [ $1 -eq 0 ]; then
    echo -e -n ${GREEN}.${END}
  else
    echo -e -n ${RED}F${END}
  fi
}

function _main() {
  # function arguments
  local spec_file=$1
  local driver=${2:-'local'}
  local target=${3:-''}
  local verbose=${4:-0}

  # function variables
  local total_specs=0
  local failed_specs=0
  local result_summary=""
  local cmd_result=$(mktemp /tmp/$0.XXX)
  local exit_status=0

  # loop through specs
  while read spec; do
    # skip comments
    if echo $spec | grep -q '^#'; then
      continue
    fi

    # form command string
    case $driver in
      docker) cmd="docker exec ${target} ${spec}";;
      local)  cmd="${spec}";;
    esac

    # execute command
    eval "${cmd}" &> $cmd_result
    cmd_rc=$?

    # handle results
    let total_specs+=1
    if [ $cmd_rc -ne 0 ]; then
      exit_status=1
      let failed_specs+=1
      _print_cmd_summary $cmd_rc "${spec}"
      _print_cmd_output $cmd_result
    elif [[ $verbose == 1 ]]; then
      _print_cmd_summary $cmd_rc "${spec}"
      _print_cmd_output $cmd_result
    fi
    result_summary+=$(_print_dot $cmd_rc)
  done < $spec_file

  # display results
  echo -e "\n${result_summary}"
  echo "${total_specs} tests, ${failed_specs} failed"

  # cleanup
  rm $cmd_result

  # return exit code
  return $exit_status
}

# test if script is being called or sourced
if [[ $(basename ${0//-/}) == "shrift" ]]; then
  # parse cli args
  while [ ! -z $1 ]; do
    case $1 in
      -h) _usage; exit 0;;
      -d) shift; driver=$1;;
      -t) shift; target=$1;;
      -v) verbose=1;;
      *)  spec_file=$1;;
    esac
    shift
  done

  # test cli arg completeness
  if [ -z $spec_file ]; then
    _usage && _error "No spec file given"
  fi
  if [ ! -f $spec_file ]; then
    _error "No such file exists: ${spec_file}"
  fi
  if [[ $driver == "docker" ]]; then
    if [ -z $target ]; then
      _usage && _error "No target container specified"
    fi
    if ! docker info &> /dev/null; then
      _error "Cannot connect to docker daemon"
    fi
    if ! docker ps | grep -q $target; then
      _error "No such container ${target}"
    fi
  elif [ ! -z "${driver}" ] && [[ $driver != "local" ]]; then
    _error "Invalid driver specified: ${driver}"
  fi

  # run entrypoint
  # wrap args in quotes to avoid assignment issues
  _main "${spec_file}" "${driver}" "${target}" "${verbose}"

  exit $?
fi
